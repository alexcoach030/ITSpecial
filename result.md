Задание 1
Проблемы:
1. В целях адекватной работы компонента на всеъ уровнях вложенности и т.п.
   следует оставить всю работу с хуками жизненного цикла, watch непосредственно
   в компоненте, а не разделять подобным образом, как в исходном варианте -
   между App.vue и компонентом.


1. В исходном приложении рендеринг дожидается результатов
   функции setTimeout, в связи с чем игнорируется изначально
   заданная дата. Это проиходит из-за того, что первый жизненный цикл, запускающийся в исходном приложении - mounted, где уже указан SetTimeout. Исправляется добавлением в App.vue цикла created, например, где укажем интересующие нас исходные данные.

2. Неправильный формат даты в объекте Date, из-за чего заданная дата (конкретно, ноябрь в данном приложении) искажается на месяц назад
   (счет месяцев в объекте начинается с нуля)

3. В компоненте TimerComponent для определения свойства экземляра data в исходном коде
   использована стрелочная функция. Стрелочные функции не имеют собственного this, значит, в таком коде
   this будет обрабатываться как любая другая переменная и её поиск будет производиться в областях видимости выше до тех пор пока не будет найдена, часто приводя к ошибкам

4. В исходном примере в watch следует заменить immediate:true на deep:true, в таком случае коллбэк будет вызываться каждый раз, когда изменяется любое из свойств
   наблюдаемого объекта, независимо от глубины их вложенности, как указано в задании.

5. Использование методов watch вместо вычисляемых свойств ведет к тому, что результаты методов не кэшируются (в отличии от результатов вычисляемых свойств)

Приведение в порядок template в TimerComp и App, с учетом рекомендаций по стилю Vue, а также добавление свойства Name. Помимо приводимого мной ниже решения через вычисляемые свойства можно было:
1. Через так называемый EventBus
2. Через методы watch, как было изначально, но с учетом необходимости внесения исправлений.
   
Ссылка на sandbox с решением:
https://codesandbox.io/s/async-fast-sdvr1

Задание 2. Рефакторинг
buttonComponent.vue

line 11:
Не нужный импорт функции - удален.

watch:
line 24 в исходном примере - метод watch cursorPos:
- old на входе не нужен
- блок if else с проверкой состояния this.animate можно исключить, добавив однострочное изменение this.animate

methods:

handleClick(e)
line 41 в исходном примере - в использовании $emit необходимости нет

reppling(cursorPos)
- изменено наименование $button на button
- вместо использования переменной rippleWidthShouldBe введена функция getRippleWidth,
  которая получает на вход button.offsetWidth и button.offsetHeight. Это позволяет также избежать
  введения лишних переменных buttonWidth и buttonHeight, передавая на вход в функцию сразу необходимые данные


Добавлены пустые строки между опциями компонентов/экземляров (рекомендуется руководством Vue по стилям)

Ссылка на sandbox:
https://codesandbox.io/s/small-sunset-p0l0f

Задание 3

Доступ к глобальному скопу:
Для доступа к глобальному скоупу существует свойство globalThis (в node,
как в случае с нашим приложением, это свойство называется global).
Таким образом, в качестве target для Proxy можно задать global, куда в качестве
значения для ловушки get передавать наш action, после чего запускать.

Ссылка на sandbox:
https://codesandbox.io/s/intelligent-monad-yrsgu
